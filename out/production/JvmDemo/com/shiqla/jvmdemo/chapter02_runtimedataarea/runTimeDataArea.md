## 运行时数据区
    线程栈，本地方法区，程序计数器 和线程绑定，每个线程独享
   #### 方法区（非堆空间）
        jdk 1.8 之后方法区改为matespace 区，使用直接物理内存
        metaspace 具体分为：常量池，代码区
   #### 堆区 heap 对于内存管理主要在heap区完成,垃圾回收主要发生在堆区
        堆区主要管存储（主要包含对象类型）
        Young区：
        old区：
   #### JAVA 虚拟机栈 
        有点容易跨平台，但是相较于寄存器性能较慢
        栈区主要管运行(也存储基本类型的局部变量)
        栈帧：栈的最小存储单位,一个正在运行的方法就是一个栈帧，一个线程内，一个时间段内只能执行一个栈帧
           局部变量表：local variables table
                定义为一个数字数组，主要存储方法参数和定义在方法体内部的局部变量
                包含基本类型，对象引用,以及返回地址,在编译期都确定的类型
                不存在线程安全问题
                需要的容量大小在编译器决定，保存在方法的code中 Maximun local variables
                最基本的存储单元成为 slot,32位的类型占用一个slot ，64位的类型占用2个slot(long,double)，引用对象也占用一个slot 
                当前的栈帧如果由构造方法或者实例方法创建，那么局部变量表会保存this对象到index0.
           操作数栈： (表达式栈)
           动态链接表：（指向运行时常量池的方法引用）
           返回地址：
           额外的附加信息:
        栈不存在垃圾回收机制
        栈中主要的异常：
            Java栈可以是动态的和固定的，如果是固定的会抛出stackoverflow,栈区溢出，一般由 递归和循环调用引起
            如果是动态扩展当内存不足的时候会抛出oom(outofmemoryerror)
            虚拟机启动参数 -Xss（stack size ,栈大小） 设置最大栈大小:-Xss1024K
   #### 本地方法栈 native function stack
   #### 程序计数器 program counter
        存储指向下一个指令的地址和当前线程绑定，线程结束也会被销毁
        
   
    
    
   