## 类加载
   #### **类加载器类型：**
        bootstrap loader: 引导类加载器
            加载Java核心类库（jre/lib/rt） C/C++ 语言来实现的
        extension lodaer: 扩展类加载器；
            间接继承于 classloader ，父类加载器为bootstrap 加载器
        application loader: 应用类加载器；自己写的类都是这个加载器来加载
   #### **加载过程**
        loading：把class 文件加载进入内存
        linkind阶段：
            verify:验证阶段，检查class 是否为一个正确的符合规范的文件
            prepar: 准备阶段：为变量分配内存并初始化为0值，但是static 的final 变量不会赋值，因为在编译阶段已经赋值
            resolve: 解析阶段 讲常量池中的符号引用转为直接引用
        init 初始化：
            clinit :只有当本类中含有static修饰符的时候字节码回自动加入此方法：
                    类构造器方法,类初始化的时候会调用，会执行所有的static 代码，会按照定义顺序来执行
                    如果有父类，那么父类的clinit 必定比子类的clinit 首先执行
        
   ####  **双亲委派机制**
        Java 类加载是按需加载，到需要用的时候才去加载类对象生成一个class 对象，
        加载采用双亲委派机制，依次向上抛，直到以引导类加载器(bootstrap classloader)
        优势：
            避免类的重复加载
            保证程序安全，防止核心API 被修改 (沙箱安全机制)
         
         
        class 对象相等的条件
            类签名一致，包名和类名称
            类加载器一致

## 运行时数据区
    线程栈，本地方法区，程序计数器 和线程绑定，每个线程独享
   #### 方法区（非堆空间,metasapce）也存在垃圾回收机制，由FULLGC 回收垃圾
        jdk 1.8 之后方法区改为matespace 区，使用直接物理内存
        -XX:MetaSapceXX 设置元空间默认大小
        -XX:MaxMetaSpaceXX 设置元空间最大大小
        1.8 之后字符串常量池是放在堆空间，改进GC 效率
        1.8 之后静态变量也存放在堆区
   #### 堆区 heap 对于内存管理主要在heap区完成,垃圾回收主要发生在堆区（JDK 1.8之后）
        -Xms xx 设置堆空间初始大小 -Xmx 设置堆空间最大值
        一般会设置为一样大小，防止内存频繁扩容
        -XX:+PrintGCDetails 输出GC 的相关信息
        -XX:NewRatio 用来分配老年代和新生代的比率 一般为1:2 的关系
        如果不设置任何参数，初始大小为物理内存的1/64,最大大小为物理内存的1/4
        堆区主要管存储（主要包含对象类型）
        Young区：
            包含eden,su01 su02 ,在实际内存分配中，su01 su02只能二选一，并且2个su区一样大
            eden 和su01 ,su02 可以设置比率,6:1:1 
            每次复制之后，对于幸存者区，谁空谁是to 区
            几乎所有的对象都是在eden 被创建的,绝大部分的对象销毁也是在eden 区发生.
            -Xmn 设置新生代的大小
        old区：
            对于经过GC后的eden区，还是放不下的超大对象，会直接存放在old区
            old区会执行major GC,如果执行之后内存还是不足则直接抛出oom异常
            old区的major GC 效率比young 区的 minor GC 低10倍以上.
        元空间（metaspace）:
        
        full GC, 会回收young，old，metaspace,避免去执行，非常影响性能,
        System.GC 会建议系统去执行full gc.
        堆区的分代思想：
            更精细化的进行内存管理，根据对象的使用程度进行分区,提高内存管理效率
        内存分配策略：
            一般对象分配到eden区，
            对于大对象(经过minor GC后eden空间还是不够)可以直接存在在old 区（尽量避免过多的出现大对象）
            长期存活的对象分配到old区
            对于经过逃逸分析后，一个对象并没有逃逸出方法的话，可以直接在栈上分配，此对象也不会被GC 回收，会根据栈帧消亡而释放栈空间。
            逃逸分析：
                分析在方法中构建的对象的作用域，如果此对象的作用空间只存在此方法内部，则没有发生逃逸。
                如果此对象会被方法外医用，则发生逃逸。
                对于发生没有发生逃逸的对象，则可以直接在栈上分配。
                可以做标量替换，栈上分配，锁消除做代码优化
        TLAB: (thread local  buffer)线程私有空间，有线分配，默认1%的eden区
        开发中能使用局部变量，就不要再方法外定义
   #### JAVA 虚拟机栈 
       虚拟机启动参数 -Xss（stack size ,栈大小） 设置最大栈大小:-Xss1024K
       有点容易跨平台，但是相较于寄存器性能较慢
       栈区主要管运行(也存储基本类型的局部变量)
       栈帧：栈的最小存储单位,一个正在运行的方法就是一个栈帧，一个线程内，一个时间段内只能执行一个栈帧
            局部变量表：local variables table
                定义为一个数字数组，主要存储方法参数和定义在方法体内部的局部变量
                包含基本类型，对象引用,以及返回地址,在编译期都确定的类型
                不存在线程安全问题
                需要的容量大小在编译器决定，保存在方法的code中 Maximun local variables
                最基本的存储单元成为 slot,32位的类型占用一个slot ，64位的类型占用2个slot(long,double)，引用对象也占用一个slot 
                当前的栈帧如果由构造方法或者实例方法创建，那么局部变量表会保存this对象到index0.
           操作数栈： (表达式栈)
                使用数组实现,操作数栈大小也是编译期确定
                保存计算结果，以及临时存储计算的中间变量
           动态链接表：（指向运行时常量池的方法引用）
                在编译期保存的符号引用，在类加载之后的linking 阶段里面的resolve阶段会解析符号引用，转为直接引用
                最终的对象都存储在运行时常量池（线程共享）
           返回地址：
           额外的附加信息:
           
        栈不存在垃圾回收机制
        栈中主要的异常：
            Java栈可以是动态的和固定的，如果是固定的会抛出stackoverflow,栈区溢出，一般由 递归和循环调用引起
            如果是动态扩展当内存不足的时候会抛出oom(outofmemoryerror)
       
   #### 本地方法栈 native function stack (hotspot 是存在本地方法栈，其他虚拟机不一定存在)
        采用native 修饰的方式，一般是直接调用系统接口来实现的一些方法
        与java环境外交互
        与操作系统交互
        sun`s java
        内存溢出和虚拟机栈相同，也包含stackoverflow 以及oom,
   #### 程序计数器 program counter
        存储指向下一个指令的地址和当前线程绑定，线程结束也会被销毁
   #### 变量的分类：
            按照数据类型分类：
                基本数据类型：
                引用数据类型
            按照定位的位置：
                成员：
                    可以分为类变量（静态变量），在类加载的linking阶段的prepare 阶段进行默认初始化，然后在执行clinit进行显示的赋值
                    实例变量（非静态）,在构建实例的时候使用 init 方法来进行默认赋值
                局部变量：
                    方法内部的变量，使用之前一定要显示的初始化
   #### 栈顶缓存技术
            使用CPU 的寄存器来缓存栈顶元素，比直接读取内存速度快很多     
   
## 对象的存储：
   ###对象的创建方式
    - new
    - class的newInstance(): 反射方式，调用空参构造器，且必须为public
    - Construct的newInstance():采用反射方式，调用构造器实例化,无权限要求
    - 使用clone：不调用构造器，当前类需要实现cloneable接口
    - 反序列化:从文件以及网络读取类信息实例化
    - 第三方库的objenesis:很少使用
   ### 对象创建的步骤
    1 判断对象类是否加载，链接，初始化
    2 为对象分配内存
        计算对象空间大小，然后根据大小分配内存
    3 处理并发安全问题
    4 初始化分配的空间
        属性的默认初始化
    5 设置对象的对象头
        所属类，hashcode,GC信息
    6 执行init方法初始化
        执行显示初始化，包含代码块和类构造器调用
   ### 对象内存布局
    对象头
        运行时元数据
           哈希值，GC分代年龄，锁状态标志，线程持有锁，偏向线程ID,偏向时间戳
        类型指针
           指向元数据instanceclass,确定该对象的所属类型
    实例数据
        真正的有效信息，包含代码中定义的各种类型的字段，包含父类继承的字段
        分配规则：
            相同宽度字段放在一起
            父类的放在子类之前
    对齐填充
   ###对象定位
    通过引用指针，直接定位到堆空间
    对象访问
        句柄访问
            在堆空间维护对象的句柄池，包含数据指针和类型指针
        直接指针
            直接指向堆空间的对象实体
    
   
   
    
    
   