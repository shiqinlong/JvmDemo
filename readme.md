## 类加载
   #### **类加载器类型：**
        bootstrap loader: 引导类加载器
            加载Java核心类库（jre/lib/rt） C/C++ 语言来实现的
        extension lodaer: 扩展类加载器；
            间接继承于 classloader ，父类加载器为bootstrap 加载器
        application loader: 应用类加载器；自己写的类都是这个加载器来加载
   #### **加载过程**
        loading：把class 文件加载进入内存
        linkind阶段：
            verify:验证阶段，检查class 是否为一个正确的符合规范的文件
            prepar: 准备阶段：为变量分配内存并初始化为0值，但是static 的final 变量不会赋值，因为在编译阶段已经赋值
            resolve: 解析阶段 讲常量池中的符号引用转为直接引用
        init 初始化：
            clinit :只有当本类中含有static修饰符的时候字节码回自动加入此方法：
                    类构造器方法,类初始化的时候会调用，会执行所有的static 代码，会按照定义顺序来执行
                    如果有父类，那么父类的clinit 必定比子类的clinit 首先执行
        
   ####  **双亲委派机制**
        Java 类加载是按需加载，到需要用的时候才去加载类对象生成一个class 对象，
        加载采用双亲委派机制，依次向上抛，直到以引导类加载器(bootstrap classloader)
        优势：
            避免类的重复加载
            保证程序安全，防止核心API 被修改 (沙箱安全机制)
         
         
        class 对象相等的条件
            类签名一致，包名和类名称
            类加载器一致

## 运行时数据区
    线程栈，本地方法区，程序计数器 和线程绑定，每个线程独享
   #### 方法区（非堆空间）
        jdk 1.8 之后方法区改为matespace 区，使用直接物理内存
        metaspace 具体分为：常量池，代码区
   #### 堆区 heap 对于内存管理主要在heap区完成,垃圾回收主要发生在堆区
        堆区主要管存储（主要包含对象类型）
        Young区：
        old区：
   #### JAVA 虚拟机栈 
        有点容易跨平台，但是相较于寄存器性能较慢
        栈区主要管运行(也存储基本类型的局部变量)
        栈帧：栈的最小存储单位,一个正在运行的方法就是一个栈帧，一个线程内，一个时间段内只能执行一个栈帧
           局部变量表：local variables table
                定义为一个数字数组，主要存储方法参数和定义在方法体内部的局部变量
                包含基本类型，对象引用,以及返回地址,在编译期都确定的类型
                不存在线程安全问题
                需要的容量大小在编译器决定，保存在方法的code中 Maximun local variables
                最基本的存储单元成为 slot,32位的类型占用一个slot ，64位的类型占用2个slot(long,double)，引用对象也占用一个slot 
                当前的栈帧如果由构造方法或者实例方法创建，那么局部变量表会保存this对象到index0.
           操作数栈： (表达式栈)
                使用数组实现,操作数栈大小也是编译期确定
                保存计算结果，以及临时存储计算的中间变量
           动态链接表：（指向运行时常量池的方法引用）
                在编译期保存的符号引用，在类加载之后的linking 阶段里面的resolve阶段会解析符号引用，转为直接引用
                最终的对象都存储在运行时常量池（线程共享）
           返回地址：
           额外的附加信息:
           
        栈不存在垃圾回收机制
        栈中主要的异常：
            Java栈可以是动态的和固定的，如果是固定的会抛出stackoverflow,栈区溢出，一般由 递归和循环调用引起
            如果是动态扩展当内存不足的时候会抛出oom(outofmemoryerror)
            虚拟机启动参数 -Xss（stack size ,栈大小） 设置最大栈大小:-Xss1024K
   #### 本地方法栈 native function stack
   #### 程序计数器 program counter
        存储指向下一个指令的地址和当前线程绑定，线程结束也会被销毁
   
   #### 变量的分类：
            按照数据类型分类：
                基本数据类型：
                引用数据类型
            按照定位的位置：
                成员：
                    可以分为类变量（静态变量），在类加载的linking阶段的prepare 阶段进行默认初始化，然后在执行clinit进行显示的赋值
                    实例变量（非静态）,在构建实例的时候使用 init 方法来进行默认赋值
                局部变量：
                    方法内部的变量，使用之前一定要显示的初始化
   #### 栈顶缓存技术
            使用CPU 的寄存器来缓存栈顶元素，比直接读取内存速度快很多     
   
    
    
   
   
    
    
   