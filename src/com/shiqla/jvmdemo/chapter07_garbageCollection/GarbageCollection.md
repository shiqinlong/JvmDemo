##垃圾回收（GC）
 #### 垃圾回收概述
    什么是垃圾？没有任何指针指向的对象
    eden 区频繁回收
    old 较少回收
    metadata区 基本不回收,触发full gc 会回收metadata
 #### 垃圾回收算法
     标记阶段：
        引用计数：
            用来计数对象被应用的次数，如果计数为0怎是垃圾，需要被回收
            优点：
                实现比较简单，垃圾对象便于标识，判定效率比较高，回收没有延迟性
            缺点：
                需要单独的字段存储计数器，增加了存储空间的开销
                每次赋值都要跟新计数器，伴随着加减法，增加时间开销
                无法处理循环引用的情况，致命缺陷，所以现在不使用这种算法。
        可达性分析（根搜索算法,追踪性垃圾收集）
            解决了引用计数算法中的循环引用问题,防止内存泄漏
            使用GC ROOTS 的集合，自上而下的的方式，搜索被根对象集合所连接的目标是否可达
            搜索路径成为引用链
            GC ROOTS:
                虚拟机栈中引用的对象
                本地方法栈的引用对象
                类静态变量的引用对象
                常量引用对象
                被同步锁持有对象
                虚拟机内部引用
     清除阶段：
        标记清除 （mark - sweep）：
            标记的为可达对象，未标记的为垃圾需要被回收,标记存放在对象的header中
            缺点：
                效率不是很高，GC 的时候需要停止整个应用程序(STW)，导致用户体验差
                导致内存碎片化问题
        复制：
            或者的内存分为2块区域，每次使用一块，收回的时候把正在使用的内容复制并顺序存储到另一个块区域，然后清除开始的区，
            在新生代使用的复制算法来垃圾回收
            优点：
                没有标记清除过程，实现简单，运行高效
                没有内存碎片化问题。
            缺点：
                额外的内存开销，需要维护对象的引用地址
            特别：
                如果存活对象多，需要复制的对象过多，所以在存活对象比较少的时候，效率较高
        标记压缩（mark-compact）：
            old 区使用该算法来回收垃圾
            优点：
                执行后连续内存，只需要维护一个内存的起始地址。
                对比复制算法，减少内存开销
            缺点：
                效率比标记清除低，需要从新维护对象应用地址。
     对象终止机制（finalization），回收之前会调用此方法
        不能主动的去调用此方法
        由于此方法存在一般对象会有三种状态
            可达：
            可复活：
            不可达：
 #### 分代收集算法：
        根据堆空间的分代思想，采用不同的垃圾收回算法，从而达到整体的高效率,现在大多数垃圾回收器采用分代收集策略
 #### 增量回收算法
        把堆内存分块收集，交替和用户线程执行
        有点：减少用户线程停顿时间，增加体验
        缺点：增加线程切换以及上下文切换开销，垃圾回收总体成本上升，系统吞吐量降低
 #### 分区算法：
        将堆空间分为若干个块，根据最大停顿时间来收回若干块空间
 #### 垃圾回收相关概念
        system.gc();
            会触发full gc,无法保证一定会调用
        内存溢出与内存泄漏
            内存泄漏案例：被但实例引用的对象，不使用之后无法被回收
        stop the world
        垃圾回收的并行与并发
        安全点与安全区域
        强引用:
            引用关系存在的对象绝得不会被回收，强引用会导致内存泄漏
        软引用:
            第二次回收器会回收此引用的对象.高速缓存就是采用弱引用关系
            当内存不够的时候 会回收此引用的对象
        弱引用:
            只要垃圾收集器工作，此引用对象都会被回收
        虚引用:
            用来对象回收跟踪
        总结器引用
 #### 垃圾回收器
       CMS （concurrent-mark-sweep） 回收器：作用于老年代，一般与parnew 搭配使用，具有低延迟特性，但是老年代采用清除算法，所以会早晨内存碎片化问题
            CMS 垃圾回收流程： inital-mark(stw) -> concurrent-mark -> remark(stw) -> concurrent-sweep -> reset-thread
            在老年代中需要内存使用量达到一定的阙值的时候就要执行CMS回收。如果当前的内存不足运行CMS 垃圾收集，怎会调用serial old来重新进行老年代的垃圾回收
            会导致STW停顿边长
            缺点：
                内存碎片化问题，因为采用的是清除的方式来回收内存，导致内存碎片。所以内存分配只能使用空闲列表分配。
                对CPU资源比较敏感,导致吞吐量降低
                无法处理浮动垃圾
            +UseCMSCompactAtFullCollection 使用压缩算法来整理内存，会导致吞吐量降低，STW变长
            +CMSFullGCsBeforeCompaction Full  gc 次数之后采用压缩算法整理内存
